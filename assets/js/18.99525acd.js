(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{353:function(_,v,t){"use strict";t.r(v);var l=t(33),i=Object(l.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"_1-水平居中方案的分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-水平居中方案的分类"}},[_._v("#")]),_._v(" 1. 水平居中方案的分类")]),_._v(" "),t("p",[_._v("元素水平居中是css布局中最常见的需求，要理解css布局居中的方案，首先要对css元素布局的原理有大致的了解。")]),_._v(" "),t("p",[_._v("关于元素居中")]),_._v(" "),t("ul",[t("li",[_._v("按照元素的分类，我们可以将其分成：\n"),t("ul",[t("li",[_._v("块级元素居中")]),_._v(" "),t("li",[_._v("行内元素居中\n"),t("ul",[t("li",[_._v("text-align：center")])])])])])]),_._v(" "),t("p",[_._v("在一般布局方案中，我们往往需要设置元素的容器居中，即块级元素居中")]),_._v(" "),t("hr"),_._v(" "),t("ul",[t("li",[_._v("对于块级元素居中，我们也可以将其分成以下几类：\n"),t("ul",[t("li",[_._v("未脱离文档流\n"),t("ul",[t("li",[_._v("margin：auto")]),_._v(" "),t("li",[_._v("transfrom：translate()")])])]),_._v(" "),t("li",[_._v("脱离文档流\n"),t("ul",[t("li",[_._v("position")]),_._v(" "),t("li",[_._v("float")]),_._v(" "),t("li",[_._v("display：flex")]),_._v(" "),t("li",[_._v("display：grid")])])])])])]),_._v(" "),t("hr"),_._v(" "),t("h2",{attrs:{id:"文档流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文档流"}},[_._v("#")]),_._v(" # 文档流")]),_._v(" "),t("ul",[t("li",[_._v("对于块级元素")])]),_._v(" "),t("p",[_._v("未脱离文档流的块级元素一般按照流式布局（自上向下）来进行排列，且独占一行。此时可以通过设置margin来达到水平居中的效果")]),_._v(" "),t("h3",{attrs:{id:"盒子模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[_._v("#")]),_._v(" ## 盒子模型")]),_._v(" "),t("p",[_._v("对于块级元素，元素的横向占有面积等于下面四个属性之和")]),_._v(" "),t("ul",[t("li",[_._v("属性：\n"),t("ul",[t("li",[_._v("margin")]),_._v(" "),t("li",[_._v("border")]),_._v(" "),t("li",[_._v("padding")]),_._v(" "),t("li",[_._v("width")])])])]),_._v(" "),t("p",[_._v("除了width属性外，其他属性都有左右两边，组合在一起形成元素实际的占有宽度")]),_._v(" "),t("h3",{attrs:{id:"默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认值"}},[_._v("#")]),_._v(" ## 默认值")]),_._v(" "),t("p",[_._v("了解了盒子模型的构造，我们可以得知：")]),_._v(" "),t("p",[_._v("元素的占有宽度 = margin + border + padding + width")]),_._v(" "),t("ul",[t("li",[_._v("属性的默认值：\n"),t("ul",[t("li",[_._v("宽度的默认值是内容元素的宽度，由内容撑开")]),_._v(" "),t("li",[_._v("border的默认值为0")]),_._v(" "),t("li",[_._v("margin的默认值为0")]),_._v(" "),t("li",[_._v("padding的默认值为0")])])])]),_._v(" "),t("p",[_._v("在实际显示中，width直观表现为内容的显示区域，当每个参数都有实际值或默认值时，元素会默认靠左显示。但是由于块级元素的特性，在文档流中会独占一行，剩余的区域将不会显示其他内容。")]),_._v(" "),t("p",[_._v("我们可以将剩余区域看做是为auto设置的适应区域，")]),_._v(" "),t("p",[_._v("当上面的属性有设置为auto时，将会用剩余区域来进行填充。")]),_._v(" "),t("p",[_._v("因此，当我们需要块级元素居中时")]),_._v(" "),t("ul",[t("li",[_._v("auto默认值：")])])])}),[],!1,null,null,null);v.default=i.exports}}]);